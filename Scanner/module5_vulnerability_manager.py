# module5_vulnerability_manager.py

import json
import os
import re
from datetime import datetime

from module10_shared_utils import log_message, format_timestamp

#=========================================
#    Normalize Version String
#=========================================

def normalize_version_string(version_str):
    if not version_str or not isinstance(version_str, str):
        return None

    s = version_str.strip().lower()
    s = re.sub(r'^(v|ver|version)\s*', '', s)
    s = re.split(r'[-+_]', s, maxsplit=1)[0]

    m = re.match(r'^(\d+(?:\.\d+)*)', s)
    if not m:
        return None

    try:
        normalized = [int(p) for p in m.group(1).split('.')]
    except ValueError:
        return None

    while len(normalized) > 1 and normalized[-1] == 0:
        normalized.pop()

    return normalized


# =================================
#         Parsing
# =================================

def parse_version_rule(rule):
    """
    Parse a vulnerability version rule into a structured form.

    Returns:
        dict or None
    """

    if not rule or not isinstance(rule, str):
        return None

    rule = rule.strip()

    # ---------- Range: "1.0 - 2.3" ----------
    m = re.match(r'^(.+?)\s*-\s*(.+)$', rule)
    if m:
        min_v = normalize_version_string(m.group(1))
        max_v = normalize_version_string(m.group(2))
        if not min_v or not max_v:
            return None
        
        
        return {
            "type": "range",
            "min": min_v,
            "max": max_v
        }

    # ---------- Operator form ----------
    m = re.match(r'^(<=|>=|<|>|==|=)\s*(.+)$', rule)
    if m:
        op = m.group(1)
        version = normalize_version_string(m.group(2))
        if not version:
            return None
        
        return {
            "type": "single",
            "operator": op,
            "version": version
        }

    # ---------- Bare version → equals ----------
    version = normalize_version_string(rule)
    if version:
        return {
            "type": "single",
            "operator": "==",
            "version": version
        }

    return None


# ================================================
#    COmpare Versions
# ================================================

def compare_versions(installed, rule):
    """
    Compare installed version against parsed rule.
    Returns True if rule condition is satisfied (i.e., vulnerable).
    """

    def normalize(v, length):
        return v + [0] * (length - len(v))

    rule_type = rule.get("type")

    # ---------- SINGLE COMPARISON ----------
    if rule_type == "single":
        operator = rule["operator"]
        rule_version = rule["version"]

        max_len = max(len(installed), len(rule_version))
        a = normalize(installed, max_len)
        b = normalize(rule_version, max_len)

        if operator == "<":
            return a < b
        elif operator == "<=":
            return a <= b
        elif operator == ">":
            return a > b
        elif operator == ">=":
            return a >= b
        elif operator == "==":
            return a == b
        else:
            return False

    # ---------- RANGE COMPARISON ----------
    elif rule_type == "range":
        min_v = rule["min"]
        max_v = rule["max"]

        max_len = max(len(installed), len(min_v), len(max_v))
        a = normalize(installed, max_len)
        lo = normalize(min_v, max_len)
        hi = normalize(max_v, max_len)

        return lo <= a <= hi

    return False


# --------------------------------------------------
# DATABASE LOADING
# --------------------------------------------------

def load_vulnerability_database(filepath):
    
    result = {
        "loaded": False,
        "vulnerabilities": [],
        "metadata": {},
        "error": None
    }

    if not os.path.exists(filepath):
        result["error"] = f"Database file not found: {filepath}"
        log_message("ERROR", result["error"])
        return result

    try:
        with open(filepath, "r", encoding="utf-8") as f:
            data = json.load(f)

        if not validate_database_structure(data):
            result["error"] = "Invalid vulnerability database structure"
            return result

        valid_entries = []
        for entry in data["vulnerabilities"]:
            if validate_vulnerability_entry(entry):
                valid_entries.append(entry)

        result["vulnerabilities"] = valid_entries
        result["metadata"] = {
            "total_entries": len(valid_entries),
            "loaded_at": format_timestamp(datetime.now()),
            "filepath": filepath
        }
        result["loaded"] = True


    except Exception as e:
        result["error"] = str(e)
        log_message("ERROR", f"Failed to load vulnerability DB: {e}")

    return result


# --------------------------------------------------
# DATABASE VALIDATION
# --------------------------------------------------

def validate_database_structure(data):
    return (
        isinstance(data, dict)
        and "vulnerabilities" in data
        and isinstance(data["vulnerabilities"], list)
    )


def validate_vulnerability_entry(entry):
    required = ["software", "version_rule", "severity", "description", "cve"]

    for field in required:
        if field not in entry:
            return False

    return True


# --------------------------------------------------
# SEARCH
# --------------------------------------------------

def search_by_software_name(name, vuln_db ):

    name_norm = normalize_software_name(name)
    matches = []

    for entry in vuln_db["vulnerabilities"]:
        entry_name = normalize_software_name(entry.get("software", ""))

        if (
        name_norm == entry_name
        or name_norm.startswith(entry_name)
        or entry_name.startswith(name_norm)
        ):

            matches.append(entry)

    return matches

# ===============
# Normalize software names 
# =========================ssss

def normalize_software_name(name):
    if not name:
        return ""

    name = name.lower().strip()

    removals = [
        "(x64)", "(x86)", "®", "™", "©",
        "- 64 bit", "- 32 bit"
    ]

    for r in removals:
        name = name.replace(r.lower(), "")

    name = re.sub(r"\(.*?\)", "", name)
    name = re.sub(r"\bx64\b|\bx86\b", "", name)
    name = re.sub(r"\b\d{4}\b", "", name)
    name = re.sub(r"\s+\d+(\.\d+)*$", "", name)

    return " ".join(name.split())



# --------------------------------------------------
# CORE CHECKER
# --------------------------------------------------
def check_software_vulnerability(software_entry, vuln_db=None):
    name = software_entry.get("name")
    version = software_entry.get("version")

    if not name or not isinstance(version, list) or not vuln_db:
        return []

    installed_norm = version  # ✅ FIX

    matches = search_by_software_name(name, vuln_db)
    results = []

    for entry in matches:
        rule_str = entry.get("version_rule")
        parsed_rule = parse_version_rule(rule_str)

        if not parsed_rule:
            continue

        verdict = compare_versions(installed_norm, parsed_rule)

        if verdict is True:
            results.append({
                "software": name,
                "installed_version": version,
                "rule": rule_str,
                "severity": entry.get("severity"),
                "cve": entry.get("cve"),
                "description": entry.get("description"),
                "db_record": entry
            })

    return results


# --------------------------------------------------
# BULK EVALUATION
# --------------------------------------------------
def evaluate_all_software(installed_list, vuln_db):
    results = {
        "vulnerable": [],
        "safe": [],
        "unknown": []
    }

    if not vuln_db or not vuln_db.get("loaded"):
        log_message(
            "ERROR",
            " Vulnerability DB not loaded — skipping software vulnerability scan"
        )
        return results

    for sw in installed_list:
        try:
            software_obj = {
                "name": sw.get("name"),
                "version": sw.get("version")
            }

            matches = check_software_vulnerability(sw, vuln_db)

            if matches:
                results["vulnerable"].append({
                    "software": software_obj,
                    "vulnerabilities": matches,
                    "status": "vulnerable",
                    "reason": None
                })
            else:
                results["safe"].append({
                    "software": software_obj,
                    "vulnerabilities": [],
                    "status": "safe",
                    "reason": None
                })

        except Exception as e:
            results["unknown"].append({
                "software": sw,
                "vulnerabilities": [],
                "status": "unknown",
                "reason": str(e)
            })

    return results



# --------------------------------------------------
# CVE LOOKUP
# --------------------------------------------------

def get_cve_details(cve_id, vuln_db = None):
    if not vuln_db or not vuln_db.get("loaded"):
        return None

    for entry in vuln_db["vulnerabilities"]:
        if entry.get("cve", "").upper() == cve_id.upper():
            return entry

    return None


